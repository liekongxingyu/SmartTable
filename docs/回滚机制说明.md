# SmartTable 回滚机制说明

## 📌 概述

SmartTable 插件实现了完整的快照回滚机制，能在用户删除消息或重新生成 AI 回复时，自动将表格数据回滚到对应的历史状态。

---

## 🔄 回滚原理详解

### 1. **快照存储位置**

快照数据存储在 `chatMetadata` 中，最终会写入 `.jsonl` 文件：

```javascript
chatData = {
  tables: {},              // 当前表格数据
  lastUpdatedIndices: {},  // 各表最后更新的消息索引
  baseFloor: 0,            // 起始楼层
  snapshots: [             // 快照数组（新增）
    {
      messageIndex: 10,
      tables: {...},
      lastUpdatedIndices: {...},
      baseFloor: 0,
      timestamp: "2026-01-30T12:00:00Z"
    },
    // ...最多保留 3 个快照
  ]
}
```

### 2. **快照创建时机**

以下操作会自动创建快照（在修改数据**之前**）：

| 触发场景        | 代码位置                      | 快照时间点 |
| --------------- | ----------------------------- | ---------- |
| AI 自动更新表格 | `refreshSelectedCategories()` | currentIdx |
| 手动添加行      | `onAddRow()`                  | currentIdx |
| 手动编辑行      | `onEditRow()`                 | currentIdx |
| 手动删除行      | `onDeleteRow()`               | currentIdx |

**关键代码示例：**

```javascript
// 在修改前创建快照
this.createSnapshot(chatData, currentIdx);

// 然后再修改数据
chatData.tables[key] = newData;
await Storage.saveChatData(chatData);
```

### 3. **回滚触发事件**

插件监听以下 SillyTavern 事件：

```javascript
// 消息删除
eventSource.on(eventTypes.MESSAGE_DELETED, (messageIndex) => {
  this.rollbackToSnapshot(messageIndex);
});

// 重新生成（Swipe）
eventSource.on(eventTypes.MESSAGE_SWIPED, (messageIndex) => {
  this.rollbackToSnapshot(messageIndex);
});
```

### 4. **回滚算法**

```javascript
async rollbackToSnapshot(targetMessageIndex) {
  // 1️⃣ 从后往前查找最后一个在目标索引之前的快照
  let targetSnapshot = null;
  for (let i = snapshots.length - 1; i >= 0; i--) {
    if (snapshots[i].messageIndex < targetMessageIndex) {
      targetSnapshot = snapshots[i];
      break;
    }
  }

  // 2️⃣ 恢复快照数据（深拷贝）
  chatData.tables = JSON.parse(JSON.stringify(targetSnapshot.tables));
  chatData.lastUpdatedIndices = { ...targetSnapshot.lastUpdatedIndices };
  chatData.baseFloor = targetSnapshot.baseFloor;

  // 3️⃣ 删除所有比目标快照更新的快照
  chatData.snapshots = snapshots.filter(
    s => s.messageIndex <= targetSnapshot.messageIndex
  );

  // 4️⃣ 保存到 jsonl 文件
  await Storage.saveChatData(chatData);
}
```

---

## 💾 数据持久化流程

```
表格数据修改
  ↓
内存操作: chatData.tables[key] = newData
  ↓
Storage.saveChatData(chatData)
  ↓
STAPI.saveMetadata()  (调用 ST 核心 API)
  ↓
写入当前聊天的 .jsonl 文件的 metadata 字段
```

**示例 jsonl 文件结构：**

```json
{
  "user_name": "You",
  "character_name": "Assistant",
  "chat_metadata": {
    "smart_table_v2": {
      "tables": {
        "tasks": [...],
        "events": [...]
      },
      "snapshots": [
        {
          "messageIndex": 5,
          "tables": {...},
          "timestamp": "2026-01-30T10:00:00Z"
        },
        {
          "messageIndex": 10,
          "tables": {...},
          "timestamp": "2026-01-30T10:30:00Z"
        }
      ]
    }
  }
}
```

---

## 🛡️ 安全机制

### 快照数量限制

```javascript
const MAX_SNAPSHOTS = 3;
if (chatData.snapshots.length > MAX_SNAPSHOTS) {
  chatData.snapshots.shift(); // 删除最旧的快照
}
```

### 深拷贝保护

所有快照都使用 `JSON.parse(JSON.stringify())` 进行深拷贝，避免引用污染。

### 边界处理

- 如果没有可用快照，回滚操作会静默失败并记录警告日志
- 如果目标消息索引之前没有快照，不会执行回滚

---

## 🎯 使用场景示例

### 场景 1: 误删消息后自动回滚

1. 用户在消息 #15 时，表格被 AI 更新（创建快照@15）
2. 用户删除了消息 #12
3. `MESSAGE_DELETED` 事件触发，`targetMessageIndex = 12`
4. 系统找到快照@10（最接近且小于 12 的）
5. 表格数据恢复到消息 #10 时的状态
6. 删除快照@15（因为它在目标快照之后）

### 场景 2: 重新生成 AI 回复

1. 用户在消息 #20 时对 AI 回复不满意，点击重新生成
2. `MESSAGE_SWIPED` 事件触发
3. 系统回滚到消息 #19 的快照
4. AI 重新生成，基于回滚后的表格数据

---

## 🔍 调试日志

插件会输出详细的日志：

```
📸 [SmartTable] 创建快照 - 消息索引: 15, 快照总数: 3
⏪ [SmartTable] 回滚完成 - 恢复到消息索引 10 的快照
   删除了 2 个后续快照
⚠️ [SmartTable] 未找到消息索引 5 之前的快照，无法回滚
```

---

## ⚙️ 配置说明

目前快照机制无需用户配置，完全自动化。未来可能开放的配置项：

- `maxSnapshots`: 最大快照数量（默认 3）
- `autoRollback`: 是否启用自动回滚（默认 true）
- `snapshotStrategy`: 快照策略（每次/按频率/只手动）

---

## 🚀 性能考虑

- **内存开销**: 每个快照约为当前表格数据的 1 倍大小
- **存储开销**: 3 个快照 × 平均表格大小（通常 < 30KB）
- **写入频率**: 与表格更新频率一致（通过 `freq` 字段控制）
- **回滚速度**: O(n) 查找 + O(1) 恢复，通常 < 5ms

---

## 📝 总结

SmartTable 的回滚机制通过以下方式保证数据一致性：

1. ✅ 在每次数据修改前自动创建快照
2. ✅ 监听 ST 的消息变更事件
3. ✅ 智能查找并恢复到正确的历史状态
4. ✅ 所有快照数据持久化到 `.jsonl` 文件
5. ✅ 限制快照数量，避免存储膨胀

**简而言之：每次表格更新都会在 jsonl 文件的 metadata 中留下历史记录，删除或重新生成消息时自动回到对应的历史版本。**
